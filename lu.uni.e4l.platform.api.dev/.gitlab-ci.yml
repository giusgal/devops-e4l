stages:
  - commit
  - staging
  - production

##########################
####   COMMIT STAGE   ####
##########################
build:
  image: gradle:8.3-jdk17
  stage: commit
  tags:
    - docker-runner
  variables:
    GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
    GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx1024m -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError'"
  cache:
    key: gradle-cache
    paths:
      - .gradle
  script:
    - gradle clean bootJar -x test --no-daemon
  artifacts:
    name: "backend-build-$CI_COMMIT_SHORT_SHA"
    paths:
      - build
    expire_in: 1 hour

test:
  image: gradle:8.3-jdk17
  stage: commit
  tags:
    - docker-runner
  variables:
    GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
    GRADLE_OPTS: "-Dorg.gradle.daemon=false -Dorg.gradle.jvmargs='-Xmx1024m -XX:MaxMetaspaceSize=512m'"
  cache:
    key: gradle-cache
    paths:
      - .gradle
  needs:
    - job: build
      artifacts: true
  script:
    - gradle test --no-daemon
  artifacts:
    when: always  # Save results even if tests fail
    paths:
      - build/reports/tests/test/
    reports:
      junit: build/test-results/test/**/TEST-*.xml
    expire_in: 1 week

package:
  image: docker:29.1.3-cli
  stage: commit
  services:
    - name: docker:29.1.3-dind
      alias: docker
      command: ["--storage-driver=overlay2"]
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  tags:
    - docker-runner
  needs:
    - job: test
      artifacts: false
    - job: build
      artifacts: true
  before_script:
    # - docker info | grep "Storage Driver"
    # - ls -R build/libs/
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:latest

###########################
####   STAGING STAGE   ####
###########################
deploy_staging:
  stage: staging
  tags:
    - shell-runner
  needs:
    - job: package
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - docker pull $CI_REGISTRY_IMAGE:latest
    - docker compose -f ./docker/docker-compose.db.staging.yml pull
    - docker compose -f ./docker/docker-compose.backend.staging.yml pull
    - docker compose -f ./docker/docker-compose.db.staging.yml down --remove-orphans
    - docker compose -f ./docker/docker-compose.backend.staging.yml down --remove-orphans
    - docker network rm e4l-db-net-staging || true
    - docker compose -f ./docker/docker-compose.db.staging.yml up -d
    - docker compose -f ./docker/docker-compose.backend.staging.yml up -d
    # Smoke test
    - for i in {1..20}; do curl -sf http://localhost:8084/e4lapi/questionnaire && exit 0 || (echo "Waiting for backend... (Attempt $i/20)" && sleep 5); done; exit 1

system_test:
  stage: staging
  tags:
    - shell-runner
  needs:
    - job: deploy_staging
  script:
    - chmod +x ./tests/system_tests.sh
    - ./tests/system_tests.sh http://localhost:8084/e4lapi
  artifacts:
    when: always
    paths:
      - tests/
    expire_in: 1 week

uat_test:
  stage: staging
  tags:
    - shell-runner
  needs:
    - job: system_test
  variables:
    BACKEND_URL: "http://localhost:8084/e4lapi"
    FRONTEND_URL: "http://localhost:8890"
  script:
    - chmod +x ./tests/uat_tests.sh
    - ./tests/uat_tests.sh
  artifacts:
    when: always
    paths:
      - tests/
    expire_in: 1 week
  allow_failure: true

# TODO: Maybe promote to production only on manual trigger
promote_image:
  image: docker:29.1.3-cli
  stage: staging
  services:
    - name: docker:29.1.3-dind
      alias: docker
      command: ["--storage-driver=overlay2"]
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  tags:
    - docker-runner
  needs:
    - job: system_test
    - job: uat_test
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - docker pull "$CI_REGISTRY_IMAGE:latest"
    - docker tag "$CI_REGISTRY_IMAGE:latest" "$CI_REGISTRY_IMAGE:release"
    - docker push "$CI_REGISTRY_IMAGE:release"

##############################
####   PRODUCTION STAGE   ####
##############################
deploy_production:
  stage: production
  tags:
    - shell-runner
  needs:
    - job: promote_image
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    # - docker pull $CI_REGISTRY_IMAGE:release
    # Ensure database is running (IMPORTANT: it creates the network if not existing)
    - docker compose -f ./docker/docker-compose.db.prod.yml up -d
  script:
    # Check if the nginx router is running, if not, deploy both blue and green (first deployment)
    - |
      if [ -z "$(docker ps --filter name=e4l-nginx-backend-prod --format '{{.Names}}')" ]; then
        echo "Nginx not running, first deployment, deploying to blue and green environments"
        docker compose -f ./docker/docker-compose.backend.prod.blue.yml pull
        docker compose -f ./docker/docker-compose.backend.prod.blue.yml up -d
        docker compose -f ./docker/docker-compose.backend.prod.green.yml pull
        docker compose -f ./docker/docker-compose.backend.prod.green.yml up -d
        for i in {1..20}; do curl -sf http://localhost:8085/e4lapi/questionnaire && break || (echo "Waiting for blue... ($i/20)" && sleep 5); done
        for i in {1..20}; do curl -sf http://localhost:8086/e4lapi/questionnaire && break || (echo "Waiting for green... ($i/20)" && sleep 5); done
        echo "Blue and green deployment completed"
        echo "Blue listening on http://localhost:8085/e4lapi/"
        echo "Green listening on http://localhost:8086/e4lapi/"
        echo "Note: Nginx router not started - run 'release' job to make backend publicly available"
        exit 0
      fi
    # The nginx router is running, check which environment is currently released and deploy to the other
    - CURRENT_CONFIG=$(docker exec e4l-nginx-backend-prod cat /etc/nginx/nginx.conf)
    - |
      if echo "$CURRENT_CONFIG" | grep "server e4l-backend-blue-prod:8080" | grep -v "^[[:space:]]*#" | grep -q .; then
        echo "Blue is currently released, deploying to green environment"
        docker compose -f ./docker/docker-compose.backend.prod.green.yml pull
        docker compose -f ./docker/docker-compose.backend.prod.green.yml up -d
        for i in {1..20}; do curl -sf http://localhost:8086/e4lapi/questionnaire && break || (echo "Waiting for green... ($i/20)" && sleep 5); done
        echo "Green deployment completed"
        echo "Service listening on http://localhost:8086/e4lapi/"
      else
        echo "Green is currently released, deploying to blue environment"
        docker compose -f ./docker/docker-compose.backend.prod.blue.yml pull
        docker compose -f ./docker/docker-compose.backend.prod.blue.yml up -d
        for i in {1..20}; do curl -sf http://localhost:8085/e4lapi/questionnaire && break || (echo "Waiting for blue... ($i/20)" && sleep 5); done
        echo "Blue deployment completed"
        echo "Service listening on http://localhost:8085/e4lapi/"
      fi
  when: manual

release:
  stage: production
  tags:
    - shell-runner
  needs:
    - job: deploy_production
  before_script:
    # Ensure nginx is running
    - docker compose -f ./docker/docker-compose.nginx.prod.yml up -d
  script:
    # Check which environment is currently active in the running nginx container
    - |
      CURRENT_CONFIG=$(docker exec e4l-nginx-backend-prod cat /etc/nginx/nginx.conf)
      # If blue is active, release green
      if echo "$CURRENT_CONFIG" | grep "server e4l-backend-blue-prod:8080" | grep -v "^[[:space:]]*#" | grep -q .; then
        echo "Releasing green"
        sed -i 's/server e4l-backend-blue-prod:8080/# server e4l-backend-blue-prod:8080/' ./docker/nginx.conf
        sed -i 's/# server e4l-backend-green-prod:8080/server e4l-backend-green-prod:8080/' ./docker/nginx.conf
      else
        echo "Releasing blue"
        sed -i 's/server e4l-backend-green-prod:8080/# server e4l-backend-green-prod:8080/' ./docker/nginx.conf
        sed -i 's/# server e4l-backend-blue-prod:8080/server e4l-backend-blue-prod:8080/' ./docker/nginx.conf
      fi
    - docker compose -f ./docker/docker-compose.nginx.prod.yml up -d --force-recreate
    # Smoke test through nginx
    - for i in {1..10}; do curl -sf http://localhost:8090/e4lapi/questionnaire && break || (echo "Testing nginx... ($i/10)" && sleep 5); done
    - echo "Release completed"
    - echo "Service is now live on http://localhost:8090/e4lapi/"
  when: manual

rollback:
  stage: production
  tags:
    - shell-runner
  needs:
    - job: release
  script:
    # Check which environment is currently active in the running nginx container
    - |
      CURRENT_CONFIG=$(docker exec e4l-nginx-backend-prod cat /etc/nginx/nginx.conf)
      # If blue is active, roll back to green
      if echo "$CURRENT_CONFIG" | grep "server e4l-backend-blue-prod:8080" | grep -v "^[[:space:]]*#" | grep -q .; then
        echo "Rolling back from blue to green"
        sed -i 's/server e4l-backend-blue-prod:8080/# server e4l-backend-blue-prod:8080/' ./docker/nginx.conf
        sed -i 's/# server e4l-backend-green-prod:8080/server e4l-backend-green-prod:8080/' ./docker/nginx.conf
      else
        echo "Rolling back from green to blue"
        sed -i 's/server e4l-backend-green-prod:8080/# server e4l-backend-green-prod:8080/' ./docker/nginx.conf
        sed -i 's/# server e4l-backend-blue-prod:8080/server e4l-backend-blue-prod:8080/' ./docker/nginx.conf
      fi
    - docker compose -f ./docker/docker-compose.nginx.prod.yml up -d --force-recreate
    # Smoke test through nginx
    - for i in {1..10}; do curl -sf http://localhost:8090/e4lapi/questionnaire && break || (echo "Testing nginx... ($i/10)" && sleep 5); done
    - echo "Rollback completed"
  when: manual
  # environment:
  #   name: production
  #   action: rollback